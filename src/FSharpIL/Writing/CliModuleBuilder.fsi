namespace FSharpIL.Writing

open System
open System.Collections.Immutable
open System.Runtime.CompilerServices

open FSharpIL.Cli
open FSharpIL.Metadata
open FSharpIL.Metadata.Cil
open FSharpIL.Metadata.Tables

open FSharpIL.Writing.Cil

open FSharpIL.Utilities.Collections

[<AbstractClass>]
type DefinedMethodBody = // TODO: Maybe move MethodBodyBuilder higher up to allow its usage in the FSharpIL.Cli namespace.
    val InitLocals: InitLocals
    val LocalTypes: ImmutableArray<LocalType>

    new: localTypes: ImmutableArray<LocalType> * initLocals: InitLocals -> DefinedMethodBody
    new: localTypes: ImmutableArray<LocalType> -> DefinedMethodBody
    new: unit -> DefinedMethodBody

    abstract WriteInstructions: byref<MethodBodyBuilder> * MetadataTokenSource -> uint16

[<NoComparison; NoEquality>]
type EntryPoint

[<IsReadOnly; Struct>]
[<NoComparison; NoEquality>]
type CustomAttributeList =
    member Count: int32
    member Add: CustomAttribute -> IValidationError option

[<Sealed>]
type DefinedTypeMembers =
    [<DefaultValue>] val mutable internal Field: HybridHashSet<DefinedField>
    [<DefaultValue>] val mutable internal Method: HybridHashSet<DefinedMethod>
    [<DefaultValue>] val mutable internal MethodBodyLookup: LateInitDictionary<DefinedMethod, DefinedMethodBody>

    member Owner: DefinedType
    member FieldCount: int32
    member MethodCount: int32
    //member PropertyCount: int32
    //member EventCount: int32

    member DefineMethod:
        method: DefinedMethod *
        body: DefinedMethodBody voption *
        attributes: CustomAttributeList ref voption ->
            ValidationResult<MethodTok<DefinedType, DefinedMethod>>

    member DefineEntryPoint:
        method: EntryPointMethod *
        body: DefinedMethodBody *
        attributes: CustomAttributeList ref voption ->
            ValidationResult<MethodTok<DefinedType, MethodDefinition<MethodKinds.Static>>>

    member ContainsField: field: DefinedField -> bool
    member ContainsMethod: method: DefinedMethod -> bool

//[<IsReadOnly; Struct>]
//type DefinedTypeMembers<'Kind when 'Kind :> IAttributeTag<TypeDefFlags> and 'Kind : struct> =
//    val Members: DefinedTypeMembers

[<Sealed>]
type ReferencedTypeMembers =
    [<DefaultValue>] val mutable internal Field: HybridHashSet<ReferencedField>
    [<DefaultValue>] val mutable internal Method: HybridHashSet<ReferencedMethod>

    member Owner: ReferencedType
    member FieldCount: int32
    member MethodCount: int32
    //member PropertyCount: int32
    //member EventCount: int32

    member ReferenceMethod: method: ReferencedMethod -> ValidationResult<MethodTok<ReferencedType, ReferencedMethod>>

    member ContainsField: field: ReferencedField -> bool
    member ContainsMethod: method: ReferencedMethod -> bool

[<IsReadOnly; Struct>]
type ReferencedTypeMembers<'Kind when 'Kind :> IAttributeTag<TypeDefFlags> and 'Kind : struct> =
    val Members: ReferencedTypeMembers

[<AbstractClass; Sealed; Extension>]
type TypeMemberExtensions =
    [<Extension>]
    static member ReferenceMethod :
        members: ReferencedTypeMembers<'Kind> *
        method: MethodReference<MethodKinds.ObjectConstructor> ->
            ValidationResult<MethodTok<TypeReference<'Kind>, MethodReference<MethodKinds.ObjectConstructor>>>
            when 'Kind :> TypeKinds.IHasConstructor

    [<Extension>]
    static member ReferenceMethod :
        members: ReferencedTypeMembers<'Kind> *
        method: MethodReference<MethodKinds.Static> ->
            ValidationResult<MethodTok<TypeReference<'Kind>, MethodReference<MethodKinds.Static>>>
            when 'Kind :> TypeAttributes.IHasStaticMethods

    //static member DefineEntryPoint

/// Builds a CLI metadata module (I.9).
[<Sealed>]
type CliModuleBuilder =
    /// <summary>Creates a new CLI metadata module.</summary>
    /// <param name="name">The name of the module.</param>
    /// <param name="mvid">
    /// Used to uniquely identify the module, can be generated by any algorithim that generates new GUIDs or can be based off of
    /// the contents of the module for deterministic outputs.
    /// </param>
    /// <param name="cliMetadataHeader">
    /// Specifies the version of the runtime the module can run on and if the module can only run on a 32-bit machine, defaults to
    /// the latest runtime version if omitted.
    /// </param>
    /// <param name="cliMetadataRoot">
    /// Specifies which implementation of the Common Language Runtime the module is intended to be run on, defaults to the latest
    /// Microsoft-specific implementation if omitted.
    /// </param>
    /// <param name="assembly">
    /// Defines an assembly manifest, if omitted then the resulting Portable Executable file is not an assembly.
    /// </param>
    /// <param name="warnings">
    /// A collection to which warning objects are added to, if omitted any <c>WARNING</c> checks are ignored.
    /// </param>
    /// <param name="typeDefCapacity">The initial number of type definitions that the module can contain.</param>
    /// <param name="typeRefCapacity">The initial number of type references that the module can contain.</param>
    /// <param name="assemblyRefCapacity">The initial number of assembly references that the module can contain.</param>
    new :
        name: Identifier *
        ?mvid: Guid *
        ?cliMetadataHeader: CliHeader *
        ?cliMetadataRoot: CliMetadataRoot<FSharpIL.Omitted, FSharpIL.Omitted> *
        ?assembly: DefinedAssembly *
        ?warnings: ValidationWarningsBuilder *
        ?typeDefCapacity: int32 *
        ?typeRefCapacity: int32 *
        ?assemblyRefCapacity: int32 -> CliModuleBuilder

    member Mvid: Guid
    member Name: Identifier
    member ModuleCustomAttributes: CustomAttributeList
    member Assembly: DefinedAssembly option
    member AssemblyCustomAttributes: CustomAttributeList option
    member EntryPoint: EntryPoint // TODO: Allow a File row to also be an entry point.
    member ValidationWarnings: ValidationWarningsCollection
    /// <summary>
    /// Gets the members of the <c>&lt;Module&gt;</c> special type, which represents the global members defined in the module.
    /// </summary>
    member GlobalMembers: DefinedTypeMembers

    member DefineAssembly: assembly: DefinedAssembly -> ValidationResult<CustomAttributeList>

    /// Adds a reference to another assembly.
    member ReferenceAssembly: assembly: ReferencedAssembly -> unit

    // TODO: For methods that add things that can also have custom attributes, figure out how to avoid allocating a CustomAttributeList if user doesn't want/need the CA list.

    member DefineType: definition: DefinedType -> ValidationResult<struct(CustomAttributeList * DefinedTypeMembers)>
    member DefineType: definition: DefinedType * attributes: CustomAttributeList ref voption -> ValidationResult<DefinedTypeMembers>

    //member DefineType: DefinedType * attributes: outref<CustomAttributeList> -> ValidationResult<DefinedTypeMembers>

    // TODO: For specific TypeDefinition kinds, return a struct that wraps DefinedTypeMembers and only allows addition of certain members.
    //member DefineType: TypeDefinition<TypeKinds.StaticClass> -> ValidationResult<>

    member ReferenceType: reference: ReferencedType -> ValidationResult<ReferencedTypeMembers>
    member ReferenceType: reference: TypeReference<'Kind> -> ValidationResult<ReferencedTypeMembers<'Kind>>

    /// <summary>
    /// Attempts to add a <see cref="T:System.Runtime.Versioning.TargetFrameworkAttribute"/> to the current assembly.
    /// </summary>
    /// <returns>
    /// <c>None</c> if the attribute was successfully added; otherwise an error object if the current assembly is not defined or
    /// if the custom attribute constructor does not take exactly 1 argument.
    /// </returns>
    member SetTargetFramework: tfm: string * ctor: CustomAttributeCtor -> IValidationError option

    member internal Serialize: unit -> CliMetadataBuilder
